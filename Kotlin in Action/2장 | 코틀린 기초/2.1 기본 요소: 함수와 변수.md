# 2.1 기본 요소: 함수와 변수
모든 프로그램을 구성하는 기본 단위인 함수와 변수 살펴보기

## 1) Hello, World!
> 코틀린 특성
- 함수 선언시 fun 키워드 사용
- 파라미터 이름 뒤에 파라미터의 타입 작성
- 자바와 달리 함수를 최상위 수준에 정의 가능 (클래스 안에 함수를 넣을 필요 없음)
- 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않음 (배열 == 일반적인 클래스)
- 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 wrapper 클래스를 제공 (ex. println)
- 라인 끝에 세미콜론(;)을 붙이지 않아도 됨

## 2) 함수
- fun 키워드로 시작
- fun [함수 이름] [파라미터 목록]: [반환 타입] { 함수 본문 }

```kotlin
fun max(a: Int, b: Int): Int {
    return if (a > b) a else b
}
```

코틀린에서 if는 문이 아니라 식이다.

> 문(statement)과 식(expression)의 구분
- 문: 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다.
- 식: 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있다.
- 자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다. 제어 구조를 다른 식으로 엮어낼 수 있으면 여러 일반적인 패턴을 아주 간결하게 표현할 수 있다.
- 반면 대입문은 자바에서는 식이었지만 코틀린에서는 문이다.

### 식이 본문인 함수
위의 함수를 더 간결하게 표현할 수 있다.

```kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

- 코틀린에서는 식이 본문인 함수가 자주 쓰임
- 단순한 산술식이나 함수 호출 식뿐 아니라 if, when, try 등의 더 복잡한 식도 자주 쓰임

위의 함수에서 반환 타입을 생략하면 max 함수를 더 간결하게 만들 수 있다.

```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```

> 반환 타입을 생략할 수 있는 이유
- 컴파일러가 함수 본문 식을 분석해 식의 결과 타입을 함수 반환 타입으로 정해줌
- 이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 **타입 추론**(type inference)이라 부름
- 식이 본문인 함수의 반환 타입만 생략 가능

## 3) 변수
- 자바에서는 변수를 선언할 때 타입이 맨 앞에 오는 반면 코틀린에서는 타입 지정을 생략하는 경우가 흔함
- 식이 본문인 함수에서와 마찬가지로 타입을 지정하지 않으면 컴파일러가 초기화 식을 분석해 변수 타입을 지정함

```kotlin
val question = "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"
val answer = 42
```

- 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 **반드시** 명시해야 함
- 초기화 식이 없다면 변수에 저장될 값의 정보가 없기 때문에 컴파일러가 타입을 추론할 수 없음

### 변경 가능한 변수와 변경 불가능한 변수
변수 선언 시 사용하는 키워드는 2가지가 있다.
- **val**(value)
  - 변경 불가능한(immutable) 참조를 저장하는 변수
  - 일단 초기화하고 나면 재대입 불가능
  - 자바의 final에 해당
- **var**(variable)
  - 변경 가능한(mutable) 참조
  - 값 변경 가능
  - 자바의 일반 변수에 해당

기본적으로 모든 변수를 val로 선언하고, 나중에 꼭 필요할 때에만 var로 변경하는 것이 좋다. 변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워진다.

#### ㄱ. val 변수
1. val 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다. 어떤 블록이 실행될 때 오직 하나의 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 val 값을 다른 여러 값으로 초기화할 수 있다.
```kotlin
val message: String
if (canPerformOperation()) {
    message = "Success"
}
else {
    message = "Failed"
}
```

2. val 참조 자체는 불변이라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.
```kotlin
val languages = arrayListOf("Java")
languages.add("Kotlin")
```

#### ㄴ. var 변수
- 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.
- 컴파일러는 변수 선언 시점의 초기화 식으로부터 변수 타입을 추론하며, 변수 선언 이후 변수 재대입이 이루어질 때는 이미 추론한 변수 타입을 염두에 두고 검사한다.
- 다른 타입의 값을 저장하는 방법
  - 변환 함수를 써서 값을 변수의 타입으로 변환하기
  - 값을 변수에 대입할 수 있는 타입으로 강제 형 변환하기

## 4) 더 쉽게 문자열 형식 지정: 문자열 템플릿
여러 스크립트 언어와 비슷하게 코틀린에서도 변수를 문자열 안에 사용할 수 있음
- 자바의 문자열 접합 연산과 동일한 기능을 하지만 좀 더 간결하며 효율적임
- $ 문자를 문자열에 넣고 싶으면 \를 사용해 $를 escape시켜야 함
- 복잡한 식은 중괄호({})로 둘러싸서 문자열 템플릿 안에 넣을 수 있음
- 중괄호로 둘러싼 식 안에서 문자열 템플릿을 사용해도 됨

```kotlin
fun main(args: Array<String>) {
    println("Hello, ${if (args.size > 0) args[0] else "someone"}!")
}
```

> 문자열 템플릿 안에서 변수를 사용하는 경우 ${name}처럼 중괄호로 변수명을 감싸는 습관을 들이면 좋다. 정규식 등을 통해 처리하기도 쉽고 사람이 읽을 때도 변수를 식별하기 쉽다.
