# :bulb: CPU 바운드와 I/O 바운드
- 병목 현상
  - 다양한 유형의 성능저하가 발생하는 지점
  - 애플리케이션의 성능을 최적화할 때 가장 중요한 사항

동시성과 병렬성이 CPU나 I/O 연산에 바인딩됐는지 여부에 따라 알고리즘의 성능이 영향을 받을 수 있다.

> 동시성 코드가 항상 필요한 것도 아니고 이를 통해 꼭 이득을 얻는 것도 아니다. 코드의 병목과 스레드 및 코루틴의 작동방식과 동시성 및 병렬성 간의 차이를 이해해 두면 동시성 소프트웨어를 언제 어떻게 구현해야 하는지를 제대로 판단할 수 있다.

## 1. CPU 바운드와 I/O 바운드
- CPU 바운드
  - CPU만 완료하면 되는 작업을 중심으로 구현되는 알고리즘
  - 성능은 실행 중인 CPU의 성능에 좌우되며 CPU만 업그레이드해도 성능이 향상된다.
- I/O 바운드
  - 입출력 장치에 의존하는 알고리즘
  - 실행 시간은 입출력 장치의 속도에 따라 달라진다.
  - 네트워킹이나 컴퓨터 주변기기로부터의 입력을 받는 작업들도 I/O 작업이다.
  - I/O 작업을 기준으로 성능에 대한 병목 현상을 일으키며, 이는 최적화가 외부 시스템이나 장치에 의존한다는 것을 의미한다.

> 많은 I/O 바운드를 갖는 데이터베이스와 같은 고성능 애플리케이션은 결국 실행 중인 기기의 스토리지 액세스 속도에 따라 성능이 좌우된다. 스마트폰 애플리케이션과 같은 네트워킹 기반 애플리케이션도 마찬가지로 인터넷 연결 속도에 따라 성능이 좌우된다.

## 2. CPU 바운드 알고리즘에서의 동시성과 병렬성
다중 코어에서 병렬성을 활용하면 성능을 향상시킬 수 있지만 단일 코어에서 동시성을 구현하면 성능이 저하되기도 한다.

- 단일 코어에서 동시 실행
  - 하나의 코어가 여러 스레드 사이에서 교차 배치되며 매번 명령을 수행하고 다음 스레드로 전환된다. 이 때 전환 프로세스를 context switching이라고 한다.
  - ***context switching***은 현재 스레드의 상태를 저장한 후 다음 스레드의 상태를 적재해야 하기 때문에 전체 프로세스에 오버헤드가 발생한다.
  - 이러한 오버헤드로 인해 하나의 스레드에서 순차적으로 구현했을 때보다 단일 코어 머신에서 다중 스레드로 구현했을 때가 더 오래 걸릴 수 있다.
- 다중 코어에서 병렬 실행
  - 각 스레드가 하나의 전용 코어에서 실행된다고 가정하면 실행 시간은 코어의 개수에 비례해 줄어든다.

CPU 바운드 알고리즘을 위해서는 현재 사용 중인 장치의 코어 수를 기준으로 적절한 스레드 수를 생성해야 한다. 이렇게 하면 CPU 바운드 알고리즘을 실행하기 위해 생성된 스레드 풀인 코틀린의 CommonPool을 활용할 수 있다.

> CommonPool의 크기는 머신의 코어 수에서 1을 뺀 값이다. 4개의 코어가 있는 머신에서는 3이 된다.

## 3. I/O 바운드 알고리즘에서의 동시성과 병렬성

- I/O 바운드 알고리즘은 끊임없이 입력을 기다리기 때문에 단일 코어 기기에서 대기하는 중 다른 작업에 프로세스를 사용할 수 있도록 한다.
- 따라서 I/O 바운드인 동시성 알고리즘은 코어의 개수에 상관없이 비슷하게 수행될 것이다.
- I/O 바운드 알고리즘은 순차적인 알고리즘보다 동시성 구현에서 항상 더 나은 성능을 발휘하기 때문에 I/O 작업은 늘 동시성으로 실행하는 것이 좋다.
- GUI 애플리케이션에서는 UI 스레드를 블록하지 않는 것이 무엇보다 중요하다.
