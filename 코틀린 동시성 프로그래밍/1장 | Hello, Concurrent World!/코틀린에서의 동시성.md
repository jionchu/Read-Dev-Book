# :bulb: 코틀린에서의 동시성

동시성 프로그램에서 코틀린의 가장 차별화된 특징을 살펴보자.

## 🚫 넌 블로킹
- 스레드는 무겁고 생성하는 데 비용이 많이 들며 제한된 수의 스레드만 생성할 수 있기 때문에 스레드가 블로킹되는 것은 자원이 낭비되는 셈이다.
- 따라서 코틀린은 중단 가능한 연산(Suspendable Computations)이라는 기능을 제공한다. 스레드의 실행을 블로킹하지 않으면서 실행을 잠시 중단한다.
- 코틀린은 channels, actors, mutual exclusions와 같은 훌륭한 기본형도 제공해 스레드를 블록하지 않고 동시성 코드를 효과적으로 통신하고 동기화하는 메커니즘을 제공한다.

## ‼️ 명시적인 선언

동시성은 깊은 고민과 설계가 필요하기 때문에 연산이 동시에 실행되어야 하는 시점을 명시적으로 만드는 것이 중요하다. 일시 중단 가능한 연산(Suspendable computations)은 기본적으로 순차적으로 실행된다.

### 1) 가독성
- 코틀린의 동시성 코드는 순차적 코드만큼 읽기 쉽다.
- 자바를 비롯한 다른 언어에서는 동시성 코드를 읽고 이해하고 디버깅 하는 것이 어렵다는 문제점이 있다.
- 코틀린의 접근법은 관용구적인 동시성 코드를 허용한다.

```kotlin
suspend fun getProfile(id: Int) {
    val basicUserInfo = asyncGetUserInfo(id)
    val contactInfo = asyncGetContactInfo(id)

    createProfile(basicUserInfo.await(), contactInfo.await())
}
```
> 기본적으로 동시에 실행될 함수는 async로 시작하거나 Async로 끝나도록 이름을 짓는다.

suspend 메소드는 백그라운드 스레드에서 실행될 두 메소드를 호출하고 정보를 처리하기 전에 완료를 기다린다. 순차 코드처럼 간단하게 읽고 디버깅하기 쉽다.

> 비동기 함수를 작성하는 대신 suspend 함수를 작성해 async {} 또는 launch {} 블록 안에서 호출하는 것이 좋다. suspend 함수를 갖게 되면 함수의 호출자에게 더 많은 유연성을 제공하기 때문이다. 예를 들어 호출자가 언제 동시적으로 실행할 것인지를 결정할 수 있다. 또한 동시적 함수와 일시 중단 함수를 모두 작성하기를 원할 때 유용하다.

### 2) 기본형 활용
- 스레드를 만들고 관리하는 것은 동시성 코드를 작성할 때 가장 어려운 부분이다.
- 언제 스레드를 만들 것인가를 아는 것뿐만 아니라 얼마나 많은 스레드를 만드는지를 아는 것도 중요하다.
- I/O 작업 전용 스레드와 CPU 바운드 작업을 처리하는 스레드가 있어야 하는데, 스레드를 통신/동기화하는 것은 그 자체로 어렵다.
- 코틀린은 동시성 코드를 쉽게 구현할 수 있는 고급 함수와 기본형을 제공한다.
  - ***newSingleThreadContext()***: 스레드 이름을 파라미터로 설정해 스레드를 생성한다. 일단 생성되면 필요한 만큼 많은 코루틴을 수행하는 데 사용할 수 있다.
  - ***newFixedThreadPoolContext()***: 크기와 이름을 파라미터로 설정해 스레드 풀을 생성할 수 있다.
  - ***CommonPool***: CPU 바운드 작업에 최적인 thread pool이다. 최대 크기는 시스템의 코어에서 1을 뺀 값이다.
  - ***런타임***: 코루틴을 다른 스레드로 이동시키는 역할을 담당한다.
  - 채널, 뮤텍스 및 스레드 한정 등 코루틴의 통신과 동기화를 위해 필요한 많은 기본형과 기술이 제공된다.

### 3) 유연성
코틀린은 간단하면서도 유연하게 동시성을 사용하게 해주는 기본형을 많이 제공한다. 

- ***채널***: 코루틴 간에 데이터를 안전하게 보내고 받는 데 사용할 수 있는 파이프
- ***작업자 풀***: 많은 스레드에서 연산 집합의 처리를 나눌 수 있는 코루틴의 풀
- ***액터***: 채널과 코루틴을 사용하는 상태를 감싼 wrapper로 여러 스레드에서 상태를 안전하게 수정하는 메커니즘을 제공함
- ***뮤텍스***: 크리티컬 존 영역을 정의해 한 번에 하나의 스레드만 실행할 수 있도록 하는 동기화 메커니즘. 크리티컬 존에 액세스하려는 코루틴은 이전 코루틴이 크리티컬 존을 빠져나올 때까지 일시 정지된다.
- ***스레드 한정***: 코루틴의 실행을 제한해서 지정된 스레드에서만 샐행하도록 함
- ***생성자***(반복자 및 시퀀스): 필요에 따라 정보를 생성할 수 있고 새로운 정보가 필요하지 않을 때 일시 중단될 수 있는 데이터 소스

모든 것은 코틀린에서 동시성 코드를 작성할 때 수시로 사용할 수 있는 도구이며, 그 범위와 용례는 동시성 코드를 구현할 때 올바른 선택을 하는 데 도움이 될 것이다.

## 🆎 코틀린 동시성 관련 개념과 용어

- 일시 중단 연산(Suspending Computations)
  - 해당 스레드를 차단하지 않고 실행을 일시 중지할 수 있는 연산
  - 스레드를 차단하지 않고 자체 실행을 일시 중단해 다시 시작해야 할 때까지 스레드를 다른 연산에서 사용할 수 있다.
  - 다른 일시 중단 함수 또는 코루틴에서만 호출된다.
- 일시 중단 함수
  - 함수 형식의 일시 중단 연산
  - suspend 제어자 때문에 쉽게 식별할 수 있다.
- 람다 일시 중단
  - 일반적인 람다와 마찬가지로, 일시 중단 람다는 익명의 로컬 함수다.
  - 다른 일시 중단 함수를 호출함으로써 자신의 실행을 중단할 수 있다는 점에서 보통의 람다와 차이가 있다.
- 코루틴 디스패처
  - 코루틴을 시작하거나 재개할 스레드를 결정하기 위해 사용된다.
  - 모든 코루틴 디스패처는 CoroutineDispatcher 인터페이스를 구현해야 한다.
  - ***DefaultDispatcher***: 현재는 CommonPool과 같다.
  - ***CommonPool***: 공유된 백그라운드 스레드 풀에서 코루틴을 실행하고 다시 시작한다. 기본 크기는 CPU 바운드 작업에서 사용하기에 적합하다.
  - ***Unconfined***: 현재 스레드에서 코루틴을 시작하지만 어떤 스레드에서도 코루틴이 다시 재개될 수 있다. 디스패처에서는 스레드 정책을 사용하지 않는다.
  - 디스패처와 함께 필요에 따라 pool 또는 스레드를 정의하는 데 사용할 수 있는 몇 가지 빌더가 있다.
  - ***newSingleThreadContext()***: 단일 스레드로 디스패처를 생성한다. 여기에서 실행되는 코루틴은 항상 같은 스레드에서 시작되고 재개된다.
  - ***newFixedThreadPoolContext()***: 지정된 크기의 스레드 풀이 있는 디스패처를 만든다. 런차임은 디스패처에서 실행된 코루틴을 시작하고 재개할 스레드를 결정한다.
- 코루틴 빌더
  - 일시 중단 람다를 받아 그것을 실행시키는 코루틴을 생성하는 함수
  - 코루틴은 다양한 시나리오에 활용할 수 있는 다양한 코루틴 빌더를 제공한다.
  - ***async()***: 결과가 예상되는 코루틴을 시작하는 데 사용된다. 코루틴 내부에서 일어나는 모든 예외를 캡처해서 결과에 넣기 때문에 조심해서 사용해야 한다. 결과 또는 예외를 포함하는 Deferred<T>를 반환한다.
  - ***launch()***: 결과를 반환하지 안흔ㄴ 코루틴을 시작한다. 자체 혹은 자식 코루틴의 실행을 취소하기 위해 사용할 수 있는 Job을 반환한다.
  - ***runBlocking()***: 블로킹 코드를 일시 중지 가능한 코드로 연결하기 위해 작성됐다. 보통 main() 메소드와 유닛 테스트에서 사용된다. runBlocking()은 코루틴의 실행이 끝날 때까지 현재 스레드를 차단한다.
