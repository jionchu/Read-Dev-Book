# :bulb: 동시성이 어려운 이유

동시성 코드를 제대로 작성하기는 어렵다. 동시성 프로그램 자체가 어렵기도 하지만 많은 프로그래밍 언어가 더 어렵게 만든다. 어떤 언어들은 너무 번거롭게 동시성 코드를 만들기도 하고 융통성 없이 만들어 사용성을 떨어뜨리기도 한다. 코틀린은 이점을 염두해 두고 동시성 프로그래밍을 가능한 한 단순하면서도 여러 가지 사용 사례에 맞춰 조절할 수 있도록 유연하게 만들어졌다.

지금은 동시성 코드를 프로그래밍할 때 제시되는 공통된 문제점을 살펴보자.

## 1. 레이스 컨디션
- 동시성 코드를 작성할 때 가장 흔한 오류
- 코드를 동시성으로 작성했지만 순차적 코드처럼(특정한 순서로) 동작할 것이라고 예상할 때 발생

예를 들어, 데이터베이스에서 데이터를 가져오고 웹 서비스를 호출하는 기능을 동시에 수행하는 코드를 작성 중일 때, 많은 사람들이 데이터베이스가 더 빠를 것으로 가정하고 웹 서비스 작업이 끝나자 마자 데이터베이스 작업 결과에 접근하려고 한다. 데이터베이스 작업이 웹 서비스 호출보다 오래 걸릴 때마다 애플리케이션이 중단되거나 일관되지 않은 상태에 빠지게 된다.

```kotlin
data class UserInfo(val name: String, val lastName: String, val id: Int)

lateinit var user: UserInfo

fun main(args: Array<String>) = runBlocking {
    asyncGetUserInfo(1)
    // Do some other operations
    delay(1000)

    println("User ${user.id} is ${user.name}")
}

fun asyncGetUserInfo(id: Int) = async {
    delay(1100)
    user = UserInfo(id = id, name = "Susan", lastName = "Calvin")
}
```

위 코드를 실행하면 user의 정보를 출력하려는 동안 user가 초기화되지 않아서 main()이 중단된다. 레이스 컨디션을 고치려면 정보에 접근하려고 하기 전에 정보를 얻을 때까지 명시적으로 기다려야 한다.

## 2. 원자성 위반
- 작업이 사용하는 데이터를 간섭 없이 접근할 수 있음
- 단일 스레드 애플리케이션에서는 모든 코드가 순차적으로 실행되기 때문에 모든 작업이 모두 원자(atomic)이다.
- 원자성은 객체의 상태가 동시에 수정될 수 있을 때 필요하며 상태의 수정이 겹치지 않도록 보장해야 한다. 수정이 겹친다는 것은 데이터 손실이 발생할 수 있다는 뜻이다.

```kotlin
var counter = 0
fun main(args: Array<String>) = runBlocking {
    val workerA = asyncIncrement(2000)
    val workerB = asyncIncrement(100)
    workerA.await()
    workerB.await()
    print("counter [$counter]")
}

fun asyncIncrement(by: Int) = GlobalScope.async {
    for (i in 0 until by) {
        counter++
    }
}
```

위 코드는 asyncIncrement() 코루틴을 두 번 동시에 실행한다. 두 실행이 서로 간섭할 수 있으며, 서로 다른 코루틴 인스턴스가 값을 재정의할 수 있다. main()을 실행하면 꽤 많은 경우 2100보다 작은 값을 출력한다.

이는 counter++ 작업이 원자성이 없기 때문에 두 코루틴이 다른 코루틴이 하는 조작을 무시하고 값을 읽고 수정할 수 있는 것이다.

> 코루틴 중 한 번에 하나만 counter++를 실행해야 한다.

## 3. 교착 상태
- 동시성 코드가 올바르게 동기화되려면 다른 스레드에서 작업이 완료되는 동안 실행을 일시 중단하거나 차단해야 하는데, ***순환적 의존성***이 생기는 경우 전체 애플리케이션의 실행이 중단될 수 있다.
- jobA와 jobB가 둘 다 서로의 작업이 끝나기를 기다리고 있다면 누구도 끝나지 않는다.
- 일반적으로 복잡한 잠금 연관관계(network of locks)에 의해 발생하며 레이스 컨디션과 자주 같이 발생한다.

## 4. 라이브 락
- 애플리케이션이 올바르게 실행을 계속할 수 없을 때 발생하는 교착상태와 유사하다.
- 라이브 락이 진행될 때 애플리케이션의 상태는 지속적으로 변하지만 애플리케이션이 정상 실행으로 돌아오지 못하게 하는 방향으로 변한다.
- 교착 상태를 복구하도록 설계된 알고리즘에서 라이브 락이 발생하는 경우가 많다. 교착 상태에서 복구하려는 시도가 라이브 락을 만들어 낼 수도 있는 것이다.
- 비유하자면 길에서 마주쳤을 때 서로 피하게 되면서 계속 서로의 길을 막게 되는 경우
